<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.ksdshpx.mybatis.mapper.EmployeeMapper">
    <!--
        namespace:名称空间,指定为接口的全类名
        id:唯一标识
        resultType:返回值类型
        #{id}:从传递过来的参数中取出id值
    -->
    <select id="selectEmp" resultType="cn.ksdshpx.mybatis.beans.Employee">
        <!--select id,last_name as lastName,gender,email from tbl_employee where id = #{id}-->
        SELECT * FROM tbl_employee WHERE id = #{id}
    </select>

    <!--public Employee getEmpById(Integer id);-->
    <!--
    <select id="getEmpById" resultType="cn.ksdshpx.mybatis.beans.Employee">
        select id,last_name as lastName,gender,email from tbl_employee where id = #{id}
    </select>
    -->
    <select id="getEmpById" resultType="employee" databaseId="mysql">
        SELECT id, last_name AS lastName, gender, email
        FROM tbl_employee
        WHERE id = #{id}
    </select>

    <!--void addEmp(Employee employee);-->
    <!--parameterType可以省略不写-->
    <!--
        mysql支持自增主键，自增主键的获取，mybatis也是利用statement.getGeneratedKeys()
        useGeneratedKeys="true":获取自增主键值策略
        keyProperty:指定对应的主键属性，也就是mybatis获取到主键值以后，将这个值封装给JavaBean的哪个属性
    -->
    <insert id="addEmp" parameterType="cn.ksdshpx.mybatis.beans.Employee" useGeneratedKeys="true" keyProperty="id"
            databaseId="mysql">
        INSERT INTO tbl_employee (last_name, gender, email)
        VALUES (#{lastName}, #{gender}, #{email})
    </insert>

    <!--
        oracle不支持自增，使用序列来模拟自增；
        每次插入的数据的主键是从序列中拿到的值，如何获取这个值
    -->
    <insert id="addEmp" databaseId="oralce">
        <!--
            keyProperty:查出的主键封装给javabean的哪个属性
            order="BEFORE":当前sql在插入sql之前运行
            resultType:查出数据的返回值类型
        -->
        <selectKey keyProperty="id" order="BEFORE" resultType="Integer">
            <!--编写查询主键的sql-->
            SELECT employee_seq.nextval from dual
        </selectKey>
        INSERT INTO tbl_employee (id,last_name, gender, email)
        VALUES (#{id},#{lastName}, #{gender}, #{email})
    </insert>

    <!--void updateEmp(Employee employee);-->
    <update id="updateEmp">
        UPDATE tbl_employee
        SET last_name = #{lastName},
            gender    = #{gender},
            email     = #{email}
        WHERE id = #{id}
    </update>
    <!--void deleteEmpById(Integer id);-->
    <delete id="deleteEmpById">
        DELETE
        FROM tbl_employee
        WHERE id = #{id}
    </delete>
    <!--
        MyBatis参数处理：
            1.单个参数：mybatis不会做特殊处理
                #{参数名}，取出参数值
                特别注意，如果是Collection(List或Set)或数组类型，也会做特殊处理，
                将传入的集合或数组封装到Map中。
                key:Collection为collection,List为list,数组为array


            2.多个参数：mybatis会做特殊处理
                #{param1}..#{paramN}或#{arg0}..#{argn}
                多个参数会被封装成一个map(key为param1..paramN或参数的索引也可以,value为传入的参数值),#{}就是从map中获取指定的key值

            3.命名参数：明确指定封装参数时map的key
                 #{指定的key}
                 key:使用@Param注解指定的值
                 value:参数的值

            4.POJO:#{属性名}
                如果多个参数正好是业务逻辑的数据模型，我们可以直接传入POJO

            5.Map:#{key}
                如果多个参数不是业务逻辑的数据模型，没有对应的POJO，不经常使用，我们可以传入一个Map

            6.TO
                如果多个参数不是业务逻辑的数据模型，但是经常要使用，推荐来编写一个数据传输对象TO(Transfer Object)
    -->
    <!--Employee getEmpByIdAndLastName(Integer id,String lastName);-->
    <select id="getEmpByIdAndLastName" resultType="cn.ksdshpx.mybatis.beans.Employee">
        <!--select id,last_name as lastName,gender,email from tbl_employee where id = #{param1} and last_name = #{param2}-->
        <!--select id,last_name as lastName,gender,email from tbl_employee where id = #{arg0} and last_name = #{arg1}-->
        SELECT id,last_name AS lastName,gender,email FROM tbl_employee WHERE id = #{id} AND last_name = #{lastName}
</select>

    <!--Employee getEmpByMap(Map map);-->
    <select id="getEmpByMap" resultType="cn.ksdshpx.mybatis.beans.Employee">
        SELECT id, last_name AS lastName, gender, email
        FROM tbl_employee
        WHERE id = #{id}
          AND last_name = #{lastName}
    </select>
</mapper>